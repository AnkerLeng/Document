 

## 1. 算法的时间复杂度

- 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记做T(n) = O(F(n)),称O(f(n))为算法的渐进时间复杂度，简称时间复杂度
- T(n)不同，但时间复杂度可能相同。如：T(n) = n²+7n+6与T(n)=3n²+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n²)
- 计算时间复杂度的方法
  - 用常数1代替运行中间中的所有加法常数 T(n) = 3n²+7n+6 => T(n) = 3n²+7n+1
  - 修改后的运行次数函数中，只保留最高阶项T(n) = 3n²+7n+1 => T(n) = 3n²
  - 去除最高阶项的系数 T(n) = 3n² => T(n) = n² => O(n²)

### 2.1 度量一个程序（算法）执行时间的两种方法

- 1）事后统计的方法（先运行再看时间）

  > 这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二十所得时间的统计量依赖于计算机的硬件，软件等环境因素，这种方式，要在同一计算机的相同状态下运行，才能比较哪个算法速度更快

- 2）

  事前估算的方法

  （常用）

  > 通过分析某个算法的时间复杂度来判断哪个算法更优秀

### 2.2 时间频度

一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。==一个算法中的语句执行次数称为语句频度或时间频度==，记为T(n)。
 比如计算1-100所有数字之和，设计两种算法：

```
//时间频度T(n) = n+1;
int total = 0;
for(int i = 1;i<=100;i++){
    total += i;
}

//时间频度T(n) = 1;
total = (1+100)*100/2;//直接计算
复制代码
```

#### 2.2.1 忽略常数项

在时间复杂度中，随着n的变大，常数项可以忽略

- 2n+20 和 2n 随着n变大，执行曲线无限接近，20可以忽略
- 3n+10 和 3n 随着n变大，执行曲线无限接近，10可以忽略
   ![img](%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/1)

#### 2.2.2 忽略低次项

![img](%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/1-20200804224337250)

#### 2.2.3 忽略系数（不是很懂，玄学）

![img](%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/1-20200804224337307)

### 2.3 常见的时间复杂度

时间复杂度由小到大依次为==：**==O(1) < O(logn) < O(n) < O(nlogn) < O(n^2 ) < O(n^3 ) < O( n^k ) < O( 2^n )==**，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低，应尽可能地避免使用指数阶的算法

| 术语                | 阶       | 执行次数函数举例 |
| ------------------- | -------- | ---------------- |
| 常数阶              | O(1)     | 12               |
| 对数阶              | O(logn)  | 5log2n+20        |
| 线性阶              | O(n)     | 2n+3             |
| 线性对数阶          | O(nlogn) | 2n+3nlog(2)n+19  |
| 平方阶              | O(n^2 )  | 3n²+5            |
| 立方阶              | O(n^3 )  | 6n³+2n2+3n+4     |
| k次方阶（k>3且k∈Z） | O( n^k ) |                  |
| 指数阶              | O( 2^n ) |                  |

![img](%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/1-20200804224337262)

#### 常见时间复杂度举例

##### 1). 常数阶O(1)

无论代码执行了多少航，只要是没有循环等复杂结构，那么这个代码的时间复杂度就是O（1）

```
int i = 1;
int j = 2;
++i;
j++;
int m = i+j;
复制代码
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O（1）来表示它的时间复杂度.

##### 2). 对数阶O(log(2)n)

```
int i = 1;
while(i<n){
    i = i*2;
}
复制代码
```

`如果N = a^x(a>0,且a≠1)，即a的x次方等于N，那么数x就叫做以a为底N的对数(logarithm)，记作x=log(a)N。其中，a叫做对数的底数，N叫做真数，x叫做“以a为底N的对数”`
 在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了。假设循环x次之后，i就大于n了，此时这个循环就退出了，也就是说2的x次方等于n，那么x = log(2)n,也就是循环了x次之后，这个代码就结束了。因此这个代码的时间复杂度为O(log(2)n)，O(log(2)n)的这个2时间上是根据代码变化的，i= 1*3，则是O(log(3)n).

##### 3). 线性阶O(n)

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

```
for(int i = 1;i<=n;++i){
    j = i;
    j++;
}
复制代码
```

##### 4). 线性对数阶O(nlogN)

将时间复杂度为O(logN)的代码循环n遍的话，时间复杂度就是O(nlogN)

```
for(int m=1,m<n,m++){
    i = 1;
    while(i<n){
        i = i*2;
    }
}
复制代码
```

##### 5). 平方阶O(n²)

把O(n)的代码再嵌套循环一遍，它的时间复杂度就是O(n*n),如果把其中一层循环的n改成m，那它的时间复杂度就变成了O(m*n)

```
for(int i = 1;i<=n;i++){
    for(int i = 1;i<=n;i++){
        j = i;
        j++；
    }
}
复制代码
```

#### 平均时间复杂度和最坏时间复杂度

- 1)平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间
- 2)最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实力上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长
- 3)平均时间复杂度和最坏时间复杂度是否一致，和算法有关（如图）
   ![img](https://user-gold-cdn.xitu.io/2020/4/28/171c0c57e4f1139c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) ![img](%E5%A4%8D%E6%9D%82%E5%BA%A6.assets/1-20200804224337279)

## 2 算法的空间复杂度

- 类似于时间复杂度的讨论，一个算法的空间复杂度（Space Complexity）定义为该算法所耗费的存储空间，它也是问题规模n的函数。
- 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
- 在做算法分析时，==主要讨论的是时间复杂度==。从用户使用体验上看，更看重程序执行的速度。一些缓存产品（redis，memcache）和算法（基数排序）本质就是用空间换时间.

## 3. 其他术语

1. **稳定**：如果a原本在b前面，而a==b,排序之后a仍然在b的前面
2. **不稳定**：如果a原本在b前面，而a==b,排序之后a可能出现在b的后面
3. **内排序**：所有排序操作都在内存中完成
4. **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
5. **时间复杂度**：一个算法执行所耗费的时间
6. **空间复杂度**：运行完一个程序所需内存的大小
7. **n**：数据规模
8. **k**：“桶”的个数
9. **In-place**：不占用额外内存
10. **Out-place**：占用额外内存


作者：will A
链接：https://juejin.im/post/6844904143518171143
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。